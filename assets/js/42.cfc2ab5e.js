(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{415:function(v,_,t){"use strict";t.r(_);var a=t(8),e=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"浏览器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器"}},[v._v("#")]),v._v(" 浏览器")]),v._v(" "),_("h2",{attrs:{id:"浏览器渲染流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染流程"}},[v._v("#")]),v._v(" 浏览器渲染流程")]),v._v(" "),_("ul",[_("li",[v._v("解析HTML，生成DOM树。")]),v._v(" "),_("li",[v._v("解析CSS，生成CSSOM树。")]),v._v(" "),_("li",[v._v("将DOM树和CSSOM树结合，生成渲染树(Render Tree)。")]),v._v(" "),_("li",[v._v("Layout(回流)：根据生成的渲染树，进行重排，得到节点的几何信息（位置，大小）。")]),v._v(" "),_("li",[v._v("Painting(重绘)：根据渲染树以及回流得到的几何信息，得到节点的绝对像素。")]),v._v(" "),_("li",[v._v("Display：将像素发送给GPU，展示在页面上。")])]),v._v(" "),_("h2",{attrs:{id:"回流-重排-重绘"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#回流-重排-重绘"}},[v._v("#")]),v._v(" 回流（重排）& 重绘")]),v._v(" "),_("ul",[_("li",[v._v("回流：布局引擎会根据各种样式计算每个盒子在页面上的"),_("strong",[v._v("大小")]),v._v("与"),_("strong",[v._v("位置")]),v._v("。")]),v._v(" "),_("li",[v._v("重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行"),_("strong",[v._v("绘制")]),v._v("。")])]),v._v(" "),_("h3",{attrs:{id:"触发时机"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#触发时机"}},[v._v("#")]),v._v(" 触发时机")]),v._v(" "),_("h4",{attrs:{id:"回流的触发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#回流的触发"}},[v._v("#")]),v._v(" 回流的触发")]),v._v(" "),_("p",[v._v("当"),_("strong",[v._v("页面的布局")]),v._v("或者"),_("strong",[v._v("节点的几何信息")]),v._v("（位置、大小）发生变化时，触发回流。")]),v._v(" "),_("ul",[_("li",[v._v("添加或删除可见的DOM元素。")]),v._v(" "),_("li",[v._v("元素的位置发生变化。")]),v._v(" "),_("li",[v._v("元素的尺寸发生变化（高度、宽度、边框大小、外边距、内边框）。")]),v._v(" "),_("li",[v._v("内容发生变化。")]),v._v(" "),_("li",[v._v("页面一开始渲染的时候（这避免不了）。")]),v._v(" "),_("li",[v._v("浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）。")])]),v._v(" "),_("h4",{attrs:{id:"重绘的触发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#重绘的触发"}},[v._v("#")]),v._v(" 重绘的触发")]),v._v(" "),_("p",[v._v("重新"),_("strong",[v._v("绘画")]),v._v("某个节点。")]),v._v(" "),_("ul",[_("li",[v._v("回流一定触发重绘。")]),v._v(" "),_("li",[v._v("颜色改变。")]),v._v(" "),_("li",[v._v("背景改变。")]),v._v(" "),_("li",[v._v("阴影改变。")])]),v._v(" "),_("h3",{attrs:{id:"减少触发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#减少触发"}},[v._v("#")]),v._v(" 减少触发")]),v._v(" "),_("ul",[_("li",[v._v("避免使用"),_("code",[v._v("table")]),v._v("布局")]),v._v(" "),_("li",[v._v("避免设置多层内联样式")]),v._v(" "),_("li",[v._v("将动画效果应用到"),_("code",[v._v("position")]),v._v("属性为"),_("code",[v._v("absolute")]),v._v("或"),_("code",[v._v("fixed")]),v._v("的元素上")]),v._v(" "),_("li",[v._v("避免使用CSS表达式，例如："),_("code",[v._v("calc()")])]),v._v(" "),_("li",[v._v("JS通过css的"),_("code",[v._v("class")]),v._v("改变样式")]),v._v(" "),_("li",[v._v("JS避免频繁操作DOM，创建一个"),_("code",[v._v("documentFragment")]),v._v("，在它上面应用所有DOM操作，最后再把它添加到文档中")]),v._v(" "),_("li",[v._v("也可以先为元素设置"),_("code",[v._v("display:none")]),v._v("，操作结束后再把它显示出来（在display属性为none的元素上进行的DOM操作不会引发回流和重绘）")])]),v._v(" "),_("h2",{attrs:{id:"输入网址到页面显示的过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#输入网址到页面显示的过程"}},[v._v("#")]),v._v(" 输入网址到页面显示的过程")]),v._v(" "),_("h3",{attrs:{id:"dns解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dns解析"}},[v._v("#")]),v._v(" DNS解析")]),v._v(" "),_("p",[v._v("根据输入的网址逐级查找对应的IP，先从浏览器缓存 > 系统缓存(hosts文件) > 路由器缓存 > DNS服务器 > 根服务器。")]),v._v(" "),_("h3",{attrs:{id:"发起tcp连接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#发起tcp连接"}},[v._v("#")]),v._v(" 发起TCP连接")]),v._v(" "),_("h4",{attrs:{id:"三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[v._v("#")]),v._v(" 三次握手")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("第一次握手")]),v._v("：客户端发送SYN包(Seq=x)到服务器，并进入"),_("code",[v._v("SYN_SEND")]),v._v("状态，等待服务器确认。")]),v._v(" "),_("li",[_("strong",[v._v("第二次握手")]),v._v("：服务器收到SYN包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（Seq=y），即SYN+ACK包，此时服务器进入"),_("code",[v._v("SYN_RECV")]),v._v("状态。")]),v._v(" "),_("li",[_("strong",[v._v("第三次握手")]),v._v("：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入"),_("code",[v._v("ESTABLISHED")]),v._v("状态，完成三次握手。")])]),v._v(" "),_("blockquote",[_("p",[v._v("握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。")])]),v._v(" "),_("h3",{attrs:{id:"发送http请求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#发送http请求"}},[v._v("#")]),v._v(" 发送HTTP请求")]),v._v(" "),_("p",[v._v("通过TCP协议，将HTTP请求发送到服务器指定端口。")]),v._v(" "),_("h3",{attrs:{id:"服务器处理请求并返回http报文"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#服务器处理请求并返回http报文"}},[v._v("#")]),v._v(" 服务器处理请求并返回HTTP报文")]),v._v(" "),_("p",[v._v("HTTP报文分成三段：状态码，响应报头和响应报文。")]),v._v(" "),_("h3",{attrs:{id:"浏览器解析渲染页面"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器解析渲染页面"}},[v._v("#")]),v._v(" 浏览器解析渲染页面")]),v._v(" "),_("ul",[_("li",[v._v("解析HTML形成DOM树")]),v._v(" "),_("li",[v._v("解析CSS形成CSSOM树")]),v._v(" "),_("li",[v._v("合并DOM树和CSSOM树形成渲染树")]),v._v(" "),_("li",[v._v("浏览器开始渲染并绘制页面")])]),v._v(" "),_("h3",{attrs:{id:"连接结束"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#连接结束"}},[v._v("#")]),v._v(" 连接结束")]),v._v(" "),_("p",[v._v("关闭TCP链接是一个双工的过程。")]),v._v(" "),_("h4",{attrs:{id:"四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[v._v("#")]),v._v(" 四次挥手")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("第一次挥手")]),v._v("：客户端发送一个FIN，用来关闭客户端到服务器的数据传送，客户端进入"),_("code",[v._v("FIN_WAIT_1")]),v._v("状态。")]),v._v(" "),_("li",[_("strong",[v._v("第二次挥手")]),v._v("：服务器收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务器进入"),_("code",[v._v("CLOSE_WAIT")]),v._v("状态。")]),v._v(" "),_("li",[_("strong",[v._v("第三次挥手")]),v._v("：服务器发送一个FIN，用来关闭服务器到客户端的数据传送，服务器进入"),_("code",[v._v("LAST_ACK")]),v._v("状态。")]),v._v(" "),_("li",[_("strong",[v._v("第四次挥手")]),v._v("：客户端收到FIN后，客户端进入"),_("code",[v._v("TIME_WAIT")]),v._v("状态，接着发送一个ACK给服务器，确认序号为收到序号+1，服务器进入"),_("code",[v._v("CLOSED")]),v._v("状态。")])]),v._v(" "),_("h2",{attrs:{id:"get-post"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#get-post"}},[v._v("#")]),v._v(" GET & POST")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("缓存")]),v._v("：GET请求会被浏览器主动缓存，而POST不会，除非手动设置。")]),v._v(" "),_("li",[_("strong",[v._v("敏感数据")]),v._v("：GET参数通过URL传递，POST则放在请求体（Request body）中，POST更适合传递敏感数据。")]),v._v(" "),_("li",[_("strong",[v._v("编码")]),v._v("：GET请求只能进行url编码，POST支持多种编码方式。")]),v._v(" "),_("li",[_("strong",[v._v("数据大小")]),v._v("：GET是通过浏览器URL发送请求，而URL是有长度限制的，POST理论上没有大小限制，实际取决于服务器的设置。")])]),v._v(" "),_("h2",{attrs:{id:"http缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http缓存"}},[v._v("#")]),v._v(" HTTP缓存")]),v._v(" "),_("p",[v._v("简述，当浏览器再次访问一个已经访问过的资源时，它会这样做：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("根据相关字段判断是否命中强缓存，如果命中，就直接使用缓存了。")]),v._v(" "),_("blockquote",[_("p",[v._v("相关字段指的是"),_("strong",[v._v("过期值")]),v._v("，HTTP/1.0是根据"),_("code",[v._v("Expires")]),v._v("这个字段，HTTP/1.1是根据"),_("code",[v._v("Cache-Control")]),v._v("字段的"),_("code",[v._v("max-age")]),v._v("值。为了兼容，通常两个字段都会返回。")])]),v._v(" "),_("blockquote",[_("p",[v._v("使用上一次记录的"),_("code",[v._v("max-age")]),v._v("+"),_("code",[v._v("Date")]),v._v("（HTTP/1.0使用"),_("code",[v._v("Expires")]),v._v("），得到一个过期时间，比较这个"),_("strong",[v._v("过期时间")]),v._v("是否大于"),_("strong",[v._v("当前时间")]),v._v("，如果是，则表示缓存还没有过期，仍然有效，否则表示缓存失效。")])])]),v._v(" "),_("li",[_("p",[v._v("如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。")]),v._v(" "),_("blockquote",[_("p",[v._v("该请求是携带着缓存去请求的，也就是携带"),_("code",[v._v("If-Modified-Since")]),v._v("和"),_("code",[v._v("If-None-Match")]),v._v("这两个字段去的。")])])]),v._v(" "),_("li",[_("p",[v._v("如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存，否则，返回最新的资源。")]),v._v(" "),_("blockquote",[_("p",[v._v("如果缓存有效，服务器会返回一个304重定向，并且带上新的缓存指令，浏览器继续"),_("strong",[v._v("读取缓存数据")]),v._v("，并更新缓存时间。")])]),v._v(" "),_("blockquote",[_("p",[v._v("如果缓存无效，服务器会返回正常的200响应，并且带上新的缓存指令，浏览器读取"),_("strong",[v._v("响应的数据")]),v._v("，并更新缓存时间。")])])])]),v._v(" "),_("h2",{attrs:{id:"常见性能优化手段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见性能优化手段"}},[v._v("#")]),v._v(" 常见性能优化手段")]),v._v(" "),_("h3",{attrs:{id:"图片"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#图片"}},[v._v("#")]),v._v(" 图片")]),v._v(" "),_("ul",[_("li",[v._v("精灵图（雪碧图）。")]),v._v(" "),_("li",[v._v("使用字体图标代替小图片。")]),v._v(" "),_("li",[v._v("图片懒加载。")])]),v._v(" "),_("h3",{attrs:{id:"css"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#css"}},[v._v("#")]),v._v(" CSS")]),v._v(" "),_("ul",[_("li",[v._v("将CSS样式表放在页面顶部，避免已经呈现的节点会根据新的样式重绘。")]),v._v(" "),_("li",[v._v("避免使用层级较深的选择器，提供CSS渲染效率。")]),v._v(" "),_("li",[v._v("避免使用"),_("code",[v._v("calc")]),v._v("等CSS表达式，它会在页面缩放、滚动时都会重新进行计算。")]),v._v(" "),_("li",[v._v("能使用CSS实现的效果，尽量不使用JS来实现。")])]),v._v(" "),_("h3",{attrs:{id:"js"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#js"}},[v._v("#")]),v._v(" JS")]),v._v(" "),_("ul",[_("li",[v._v("将JS脚本放到页面底部，避免堵塞DOM的渲染。或者在"),_("code",[v._v("script")]),v._v("标签上使用"),_("code",[v._v("defer")]),v._v("或"),_("code",[v._v("async")]),v._v("属性进行优化。\n"),_("blockquote",[_("p",[v._v("解析器遇到JS脚本会停止渲染，优先去加载或者执行JS脚本，处理完毕后再继续渲染。"),_("br"),v._v(" "),_("code",[v._v("defer")]),v._v("属性：JS脚本的"),_("code",[v._v("加载")]),v._v("和DOM的渲染是并行的，JS脚本会等待DOM加载完才"),_("code",[v._v("执行")]),v._v("。"),_("br"),v._v(" "),_("code",[v._v("async")]),v._v("属性：JS脚本的"),_("code",[v._v("加载")]),v._v("和"),_("code",[v._v("执行")]),v._v("和DOM的渲染是并行的，JS脚本一旦加载完"),_("code",[v._v("立即执行")]),v._v("。")])])]),v._v(" "),_("li",[v._v("减少DOM的操作，如果必要，请批量操作DOM，避免频繁回流。")]),v._v(" "),_("li",[v._v("使用事件代理，避免为多个DOM元素绑定事件。")]),v._v(" "),_("li",[v._v("使用节流、防抖，限制某个函数频繁触发。")])]),v._v(" "),_("h3",{attrs:{id:"vue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[v._v("#")]),v._v(" Vue")]),v._v(" "),_("ul",[_("li",[v._v("避免"),_("code",[v._v("v-if")]),v._v("和"),_("code",[v._v("v-for")]),v._v("在同一节点上使用，"),_("code",[v._v("v-for")]),v._v("的优先级比"),_("code",[v._v("v-if")]),v._v("高，造成每次循环都会"),_("code",[v._v("v-if")]),v._v("判断。\n"),_("blockquote",[_("p",[v._v("Vue3中已将 v-if 的优先级调高于 v-for。")])])]),v._v(" "),_("li",[v._v("给"),_("code",[v._v("v-for")]),v._v("的元素加上"),_("code",[v._v("key")]),v._v("标识，优化diff的效率。")]),v._v(" "),_("li",[v._v("不需要响应式的数据使用"),_("code",[v._v("Object.freeze")]),v._v("冻结起来。")]),v._v(" "),_("li",[v._v("合理使用"),_("code",[v._v("v-show")]),v._v("/"),_("code",[v._v("v-if")]),v._v("。\n"),_("blockquote",[_("p",[_("code",[v._v("v-show")]),v._v("只是通过"),_("code",[v._v("display")]),v._v("控制元素的显隐。"),_("code",[v._v("v-if")]),v._v("会操作元素/组件的创建和销毁，代表生命周期会重新走一遍。")])])]),v._v(" "),_("li",[v._v("路由懒加载。")]),v._v(" "),_("li",[v._v("函数式组件。")]),v._v(" "),_("li",[v._v("善用"),_("code",[v._v("keep-alive")]),v._v("缓存组件。")]),v._v(" "),_("li",[v._v("定时器和全局事件记得销毁。")])]),v._v(" "),_("h3",{attrs:{id:"http"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http"}},[v._v("#")]),v._v(" HTTP")]),v._v(" "),_("ul",[_("li",[v._v("资源压缩：HTML、CSS、JS、图片都可以压缩。")]),v._v(" "),_("li",[v._v("并行连接：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量。")]),v._v(" "),_("li",[v._v("使用CDN。")]),v._v(" "),_("li",[v._v("使用HTTP缓存：添加"),_("code",[v._v("Expires")]),v._v("或者"),_("code",[v._v("Cache-Control")]),v._v("响应头。")]),v._v(" "),_("li",[v._v("Gzip压缩。")])])])}),[],!1,null,null,null);_.default=e.exports}}]);