(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{378:function(t,v,s){t.exports=s.p+"assets/img/render1.4513ebf9.png"},379:function(t,v,s){t.exports=s.p+"assets/img/render2.f766ba79.png"},466:function(t,v,s){"use strict";s.r(v);var _=s(8),a=Object(_.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"浏览器渲染机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器渲染机制"}},[t._v("#")]),t._v(" 浏览器渲染机制")]),t._v(" "),v("h2",{attrs:{id:"渲染引擎"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#渲染引擎"}},[t._v("#")]),t._v(" 渲染引擎")]),t._v(" "),v("p",[t._v("在浏览器中有以下几种常驻线程：")]),t._v(" "),v("ul",[v("li",[t._v("GUI渲染线程：负责渲染页面中的元素")]),t._v(" "),v("li",[t._v("JS引擎线程：负责解析并执行JS代码")]),t._v(" "),v("li",[t._v("定时触发器线程：负责定时器的计时")]),t._v(" "),v("li",[t._v("事件触发线程：负责管理任务队列")]),t._v(" "),v("li",[t._v("异步http请求线程：负责异步http请求")])]),t._v(" "),v("h3",{attrs:{id:"渲染引擎的工作流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#渲染引擎的工作流程"}},[t._v("#")]),t._v(" 渲染引擎的工作流程")]),t._v(" "),v("ol",[v("li",[v("code",[t._v("DOM Tree")]),t._v("：解析HTML生成DOM树")]),t._v(" "),v("li",[v("code",[t._v("CSS Rule Tree")]),t._v("：解析CSS生成CSS规则树")]),t._v(" "),v("li",[v("code",[t._v("Render Tree")]),t._v("：将DOM和CSSOM合并生成渲染树")]),t._v(" "),v("li",[v("code",[t._v("Layout")]),t._v("：遍历渲染树开始布局，计算每个位置节点大小信息")]),t._v(" "),v("li",[v("code",[t._v("Painting")]),t._v("：将渲染树的每个节点绘制到屏幕")])]),t._v(" "),v("h2",{attrs:{id:"构建dom树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#构建dom树"}},[t._v("#")]),t._v(" 构建DOM树")]),t._v(" "),v("p",[t._v("当浏览器接收到服务器响应来的html文档后，会遍历文档节点，生成DOM树")]),t._v(" "),v("h2",{attrs:{id:"构建cssom规则树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#构建cssom规则树"}},[t._v("#")]),t._v(" 构建CSSOM规则树")]),t._v(" "),v("p",[t._v("浏览器解析CSS文件并生成CSS规则树，每个CSS文件都被分析成一个StyleSheet对象，每个对象都包含CSS规则。")]),t._v(" "),v("p",[t._v("CSS规则对象包含对应于CSS语法的选择器和声明对象以及其他对象")]),t._v(" "),v("h2",{attrs:{id:"渲染阻塞"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#渲染阻塞"}},[t._v("#")]),t._v(" 渲染阻塞")]),t._v(" "),v("p",[t._v("当浏览器遇到一个"),v("code",[t._v("script")]),t._v("标记时，DOM构建将暂停，直至脚本完成执行，然后继续构建DOM。")]),t._v(" "),v("p",[t._v("每次去执行JavaScript脚本都会严重地阻塞DOM树的构建，如果JavaScript脚本还操作了CSSOM，而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建。")]),t._v(" "),v("p",[t._v("所以，"),v("code",[t._v("script")]),t._v("标签的位置很重要。实际使用时，可以遵循下面两个原则：")]),t._v(" "),v("ul",[v("li",[t._v("CSS优先：引入顺序上，CSS资源先于JavaScript资源。")]),t._v(" "),v("li",[t._v("JS置后：我们通常把JS代码放到页面底部，且JavaScript应尽量少影响DOM的构建。")])]),t._v(" "),v("h2",{attrs:{id:"构建渲染树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#构建渲染树"}},[t._v("#")]),t._v(" 构建渲染树")]),t._v(" "),v("p",[t._v("通过DOM树和CSS规则树便可以构建渲染树。")]),t._v(" "),v("p",[t._v("浏览器会先从DOM树的根节点开始遍历每个可见节点。然后对每个可见节点，找到其适配的CSS样式规则并应用")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),v("p",[t._v("渲染树用于显示，所谓可见节点，是会显示在页面的元素节点。例如"),v("code",[t._v("head")]),t._v("无样式元素，"),v("code",[t._v("display:none")]),t._v("不可见元素不占空间等等...之类都不会出现在渲染树之中。"),v("br"),t._v("\n但是这些节点还是会出现在DOM树之中，DOM跟随整个html文档的节点来构建，包括文本节点也会被构建")])]),t._v(" "),v("h2",{attrs:{id:"渲染树布局"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#渲染树布局"}},[t._v("#")]),t._v(" 渲染树布局")]),t._v(" "),v("p",[t._v("布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置。")]),t._v(" "),v("p",[t._v("布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。")]),t._v(" "),v("h2",{attrs:{id:"渲染树绘制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#渲染树绘制"}},[t._v("#")]),t._v(" 渲染树绘制")]),t._v(" "),v("p",[t._v("在绘制阶段，遍历渲染树，调用渲染器的paint方法在屏幕上显示其内容")]),t._v(" "),v("h2",{attrs:{id:"回流-重排-reflow"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#回流-重排-reflow"}},[t._v("#")]),t._v(" 回流/重排（Reflow）")]),t._v(" "),v("p",[t._v("Reflow意味着元素的"),v("code",[t._v("位置")]),t._v("或"),v("code",[t._v("大小")]),t._v("改变了，需要重新验证并计算渲染树。根据改变的范围和程度，渲染树中或大或小的部分需要重新计算。")]),t._v(" "),v("p",[t._v("有些改变会触发整个页面的Reflow，比如，滚动条出现的时候或者修改了根节点。")]),t._v(" "),v("p",[t._v("触发Reflow的css属性有这些：")]),t._v(" "),v("p",[v("img",{attrs:{src:s(378),alt:"Reflow"}})]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),v("p",[t._v("每个页面至少都会发生一次"),v("code",[t._v("Refolw")]),t._v("，也就是在第一次加载页面的时候，构建渲染树，计算位置大小信息")])]),t._v(" "),v("h2",{attrs:{id:"重绘-repaint"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重绘-repaint"}},[t._v("#")]),t._v(" 重绘（Repaint）")]),t._v(" "),v("p",[t._v("屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的"),v("code",[t._v("位置")]),t._v("、"),v("code",[t._v("大小")]),t._v("不变")]),t._v(" "),v("p",[t._v("触发Repaint的css属性有这些：")]),t._v(" "),v("p",[v("img",{attrs:{src:s(379),alt:"Repaint"}})]),t._v(" "),v("p",[t._v("根据渲染引擎的工作流程，可以得出"),v("code",[t._v("Reflow")]),t._v("一定会引发"),v("code",[t._v("Repaint")]),t._v("，而"),v("code",[t._v("Repaint")]),t._v("不一定会引发"),v("code",[t._v("Reflow")]),t._v("。")]),t._v(" "),v("p",[t._v("为了提升页面的性能，减少渲染次数，无论是"),v("code",[t._v("Reflow")]),t._v("或者"),v("code",[t._v("Repaint")]),t._v("，我们都应当尽量避免")]),t._v(" "),v("h2",{attrs:{id:"队列化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#队列化"}},[t._v("#")]),t._v(" 队列化")]),t._v(" "),v("p",[t._v("由于每次"),v("code",[t._v("Reflow")]),t._v("都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化"),v("code",[t._v("Reflow")]),t._v("过程，浏览器会将修改操作置入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列")]),t._v(" "),v("div",{staticClass:"language-js line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" el "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token string"}},[t._v('"test"')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nel"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("padding "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[t._v("'5px'")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nel"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("borderLeft "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[t._v("'1px'")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nel"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("style"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("borderRight "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2px'")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br")])]),v("p",[t._v("以上代码，有三个样式的属性被修改了，每一个都会影响元素的几何结构，引起"),v("code",[t._v("Reflow")]),t._v("。")]),t._v(" "),v("p",[t._v("在现代浏览器中，浏览器会将这些引发"),v("code",[t._v("Reflow")]),t._v("、"),v("code",[t._v("Repaint")]),t._v("的操作放到一个队列中，并批量执行。所以说，以上操作在高版本浏览器实际上只执行了一次"),v("code",[t._v("Reflow")])]),t._v(" "),v("h3",{attrs:{id:"强制刷新"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#强制刷新"}},[t._v("#")]),t._v(" 强制刷新")]),t._v(" "),v("p",[t._v("但是，当获取布局信息的操作的时候，会强制队列刷新，比如访问以下属性或者使用以下方法：")]),t._v(" "),v("ul",[v("li",[t._v("offsetTop、offsetLeft、offsetWidth、offsetHeight")]),t._v(" "),v("li",[t._v("scrollTop、scrollLeft、scrollWidth、scrollHeight")]),t._v(" "),v("li",[t._v("clientTop、clientLeft、clientWidth、clientHeight")]),t._v(" "),v("li",[t._v("getComputedStyle()")]),t._v(" "),v("li",[t._v("getBoundingClientRect")])]),t._v(" "),v("p",[t._v("以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值")]),t._v(" "),v("p",[t._v("因此，我们在修改样式的时候，最好避免使用上面列出的属性，他们都会刷新渲染队列。如果要使用它们，最好将值缓存起来")]),t._v(" "),v("h3",{attrs:{id:"优化方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优化方案"}},[t._v("#")]),t._v(" 优化方案")]),t._v(" "),v("p",[t._v("简单列举一些优化方案，来尽量避免回流和重绘的次数")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("CSS")])]),t._v(" "),v("ul",[v("li",[t._v("避免使用"),v("code",[t._v("table")]),t._v("布局")]),t._v(" "),v("li",[t._v("尽可能在DOM树的最末端改变class")]),t._v(" "),v("li",[t._v("避免设置多层内联样式")]),t._v(" "),v("li",[t._v("将动画效果应用到"),v("code",[t._v("position")]),t._v("属性为"),v("code",[t._v("absolute")]),t._v("或"),v("code",[t._v("fixed")]),t._v("的元素上")]),t._v(" "),v("li",[t._v("避免使用CSS表达式，例如："),v("code",[t._v("calc()")])])])]),t._v(" "),v("li",[v("p",[v("strong",[t._v("JavaScript")])]),t._v(" "),v("ul",[v("li",[t._v("避免频繁操作样式，最好一次性重写"),v("code",[t._v("style")]),t._v("属性，或者将样式列表定义为class并一次性更改class属性")]),t._v(" "),v("li",[t._v("避免频繁操作DOM，创建一个"),v("code",[t._v("documentFragment")]),t._v("，在它上面应用所有DOM操作，最后再把它添加到文档中")]),t._v(" "),v("li",[t._v("也可以先为元素设置"),v("code",[t._v("display:none")]),t._v("，操作结束后再把它显示出来（在display属性为none的元素上进行的DOM操作不会引发回流和重绘）")]),t._v(" "),v("li",[t._v("避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来")]),t._v(" "),v("li",[t._v("对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流")])])])]),t._v(" "),v("Vssue")],1)}),[],!1,null,null,null);v.default=a.exports}}]);