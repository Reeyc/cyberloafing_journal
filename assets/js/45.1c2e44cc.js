(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{417:function(v,_,e){"use strict";e.r(_);var t=e(8),a=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"vue"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[v._v("#")]),v._v(" Vue")]),v._v(" "),_("h2",{attrs:{id:"v-if-v-show"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#v-if-v-show"}},[v._v("#")]),v._v(" v-if & v-show")]),v._v(" "),_("ul",[_("li",[v._v("相同点：都是控制元素的显示和隐藏，值都是"),_("code",[v._v("boolean")]),v._v("类型。")]),v._v(" "),_("li",[v._v("不同点："),_("code",[v._v("v-show")]),v._v("控制的元素css的"),_("code",[v._v("display")]),v._v("属性，"),_("code",[v._v("v-if")]),v._v("控制html元素的插入和移除，如果控制的目标是组件实例，那么组件会经历创建/销毁，同理新创建的组件，生命周期也会重新走一遍。")])]),v._v(" "),_("h2",{attrs:{id:"生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[v._v("#")]),v._v(" 生命周期")]),v._v(" "),_("h3",{attrs:{id:"父子生命周期顺序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#父子生命周期顺序"}},[v._v("#")]),v._v(" 父子生命周期顺序")]),v._v(" "),_("p",[_("strong",[v._v("初始化")])]),v._v(" "),_("ol",[_("li",[v._v("父"),_("code",[v._v("beforeCreate")])]),v._v(" "),_("li",[v._v("父"),_("code",[v._v("created")])]),v._v(" "),_("li",[v._v("父"),_("code",[v._v("beforeMount")])]),v._v(" "),_("li",[v._v("子"),_("code",[v._v("beforeCreate")])]),v._v(" "),_("li",[v._v("子"),_("code",[v._v("created")])]),v._v(" "),_("li",[v._v("子"),_("code",[v._v("beforeMount")])]),v._v(" "),_("li",[v._v("子"),_("code",[v._v("mounted")])]),v._v(" "),_("li",[v._v("父"),_("code",[v._v("mounted")])])]),v._v(" "),_("hr"),v._v(" "),_("p",[_("strong",[v._v("子组件更新")])]),v._v(" "),_("ol",[_("li",[v._v("父"),_("code",[v._v("beforeUpdate")])]),v._v(" "),_("li",[v._v("子"),_("code",[v._v("beforeUpdate")])]),v._v(" "),_("li",[v._v("子"),_("code",[v._v("updated")])]),v._v(" "),_("li",[v._v("父"),_("code",[v._v("updated")])])]),v._v(" "),_("p",[_("strong",[v._v("父组件更新")])]),v._v(" "),_("ol",[_("li",[v._v("父"),_("code",[v._v("beforeUpdate")])]),v._v(" "),_("li",[v._v("父"),_("code",[v._v("updated")])])]),v._v(" "),_("hr"),v._v(" "),_("p",[_("strong",[v._v("父组件销毁")])]),v._v(" "),_("ol",[_("li",[v._v("父"),_("code",[v._v("beforeDestroy")])]),v._v(" "),_("li",[v._v("子"),_("code",[v._v("beforeDestroy")])]),v._v(" "),_("li",[v._v("子"),_("code",[v._v("destroyed")])]),v._v(" "),_("li",[v._v("父"),_("code",[v._v("destroyed")])])]),v._v(" "),_("h3",{attrs:{id:"activited-deactivated"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#activited-deactivated"}},[v._v("#")]),v._v(" activited & deactivated")]),v._v(" "),_("p",[v._v("被"),_("code",[v._v("keep-alive")]),v._v("组件包裹的组件，在激活和缓存的时候调用。")]),v._v(" "),_("ul",[_("li",[v._v("被激活时调用"),_("code",[v._v("activited")]),v._v("。")]),v._v(" "),_("li",[v._v("被缓存时调用"),_("code",[v._v("deactivated")]),v._v("。")])]),v._v(" "),_("h3",{attrs:{id:"什么阶段发起ajax请求"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么阶段发起ajax请求"}},[v._v("#")]),v._v(" 什么阶段发起ajax请求")]),v._v(" "),_("p",[v._v("在"),_("code",[v._v("data")]),v._v("初始化完成后就可以获取数据并"),_("code",[v._v("改变状态")]),v._v("，即在"),_("code",[v._v("created")]),v._v("钩子函数之后的生命周期之后都可以。")]),v._v(" "),_("p",[v._v("建议在"),_("code",[v._v("created")]),v._v("阶段发起请求，因为：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("created")]),v._v("执行时机比"),_("code",[v._v("mounted")]),v._v("快。")]),v._v(" "),_("li",[_("code",[v._v("created")]),v._v("执行时，数据已初始化完毕，可以修改数据状态了。")]),v._v(" "),_("li",[_("code",[v._v("beforeMount")]),v._v("和"),_("code",[v._v("mounted")]),v._v("等钩子在服务端渲染时不会触发。")])]),v._v(" "),_("div",{staticClass:"custom-block warning"},[_("p",{staticClass:"custom-block-title"},[v._v("WARNING")]),v._v(" "),_("p",[v._v("如果在发起ajax请求后，要操作DOM，为了保险起见可以在"),_("code",[v._v("mounted")]),v._v("中发起请求，因为"),_("code",[v._v("mounted")]),v._v("执行时代表DOM已经挂载完毕。当然也可以在"),_("code",[v._v("created")]),v._v("中使用"),_("code",[v._v("nextTick")]),v._v("回调来执行。")])]),v._v(" "),_("h2",{attrs:{id:"计算属性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计算属性"}},[v._v("#")]),v._v(" 计算属性")]),v._v(" "),_("h3",{attrs:{id:"计算属性-vs-方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计算属性-vs-方法"}},[v._v("#")]),v._v(" 计算属性 vs 方法")]),v._v(" "),_("ul",[_("li",[v._v("计算属性依赖于缓存，当里面的一个或多个属性值发生变化，才会重新计算当前属性的值。")]),v._v(" "),_("li",[v._v("方法每次调用都会执行函数。")])]),v._v(" "),_("hr"),v._v(" "),_("ul",[_("li",[_("code",[v._v("需要缓存")]),v._v("的时候使用计算属性。")]),v._v(" "),_("li",[_("code",[v._v("不需要缓存")]),v._v("的时候使用方法。")])]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("什么时候需要缓存？")]),v._v(" "),_("p",[v._v("假设有一个性能开销比较大的计算属性A，A的"),_("code",[v._v("getter")]),v._v("里面需要遍历一个巨大的数组并做大量计算，当有别的计算属性依赖于A时，没有缓存的话，每次读取这个计算属性，Vue都将不可避免的执行A的"),_("code",[v._v("getter")]),v._v("。")]),v._v(" "),_("h3",{attrs:{id:"计算属性-vs-侦听器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#计算属性-vs-侦听器"}},[v._v("#")]),v._v(" 计算属性 vs 侦听器")]),v._v(" "),_("p",[v._v("计算属性和侦听器能监听数据变化作出响应，区别如下：")]),v._v(" "),_("ul",[_("li",[v._v("computed依赖于"),_("code",[v._v("缓存")]),v._v("，watch不支持缓存，会直接触发函数。")]),v._v(" "),_("li",[v._v("computed不支持"),_("code",[v._v("异步")]),v._v("，当computed内有异步操作时无效，无法监听数据的变化。watch支持异步。")])]),v._v(" "),_("hr"),v._v(" "),_("ul",[_("li",[v._v("computed擅长处理的场景："),_("code",[v._v("一个数据受多个数据影响")]),v._v("。")]),v._v(" "),_("li",[v._v("watch擅长处理的场景："),_("code",[v._v("一个数据影响多个数据")]),v._v("。")])]),v._v(" "),_("h2",{attrs:{id:"数据响应式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据响应式"}},[v._v("#")]),v._v(" 数据响应式")]),v._v(" "),_("p",[_("strong",[v._v("为什么给data新增的属性无法响应？")])]),v._v(" "),_("p",[v._v("Vue通过"),_("code",[v._v("defineProperty")]),v._v("来劫持"),_("code",[v._v("data")]),v._v("的属性进行响应式处理，如果给对象设置的"),_("code",[v._v("key")]),v._v("原先没有定义，就无法劫持到，自然就无法做到自动更新界面。")]),v._v(" "),_("p",[_("strong",[v._v("如何解决？")])]),v._v(" "),_("ul",[_("li",[v._v("Vue提供了"),_("code",[v._v("Vue.set")]),v._v("或者"),_("code",[v._v("this.$set")]),v._v("方法来给对象新增属性值，让这个属性也带有响应式功能。")]),v._v(" "),_("li",[v._v("使用"),_("code",[v._v("this.$forceUpdate()")]),v._v("强制更新。")]),v._v(" "),_("li",[v._v("使用"),_("code",[v._v("Object.assign()")]),v._v("或者"),_("code",[v._v("扩展运算符")]),v._v("赋予新的值。")])])])}),[],!1,null,null,null);_.default=a.exports}}]);