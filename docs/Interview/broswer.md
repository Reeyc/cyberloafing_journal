# 浏览器

## 浏览器渲染流程
* 解析HTML，生成DOM树。
* 解析CSS，生成CSSOM树。
* 将DOM树和CSSOM树结合，生成渲染树(Render Tree)。
* Layout(回流)：根据生成的渲染树，进行重排，得到节点的几何信息（位置，大小）。
* Painting(重绘)：根据渲染树以及回流得到的几何信息，得到节点的绝对像素。
* Display：将像素发送给GPU，展示在页面上。

## 回流（重排）& 重绘
* 回流：布局引擎会根据各种样式计算每个盒子在页面上的**大小**与**位置**。
* 重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行**绘制**。

### 触发时机

#### 回流的触发
当**页面的布局**或者**节点的几何信息**（位置、大小）发生变化时，触发回流。
* 添加或删除可见的DOM元素。
* 元素的位置发生变化。
* 元素的尺寸发生变化（高度、宽度、边框大小、外边距、内边框）。
* 内容发生变化。
* 页面一开始渲染的时候（这避免不了）。
* 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）。

#### 重绘的触发
重新**绘画**某个节点。
* 回流一定触发重绘。
* 颜色改变。
* 背景改变。
* 阴影改变。

### 减少触发
* 避免使用`table`布局
* 避免设置多层内联样式
* 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上
* 避免使用CSS表达式，例如：`calc()`
* JS通过css的`class`改变样式
* JS避免频繁操作DOM，创建一个`documentFragment`，在它上面应用所有DOM操作，最后再把它添加到文档中
* 也可以先为元素设置`display:none`，操作结束后再把它显示出来（在display属性为none的元素上进行的DOM操作不会引发回流和重绘）

## 输入网址到页面显示的过程

### DNS解析
根据输入的网址逐级查找对应的IP，先从浏览器缓存 > 系统缓存(hosts文件) > 路由器缓存 > DNS服务器 > 根服务器。

### 发起TCP连接
#### 三次握手
* **第一次握手**：客户端发送SYN包(Seq=x)到服务器，并进入`SYN_SEND`状态，等待服务器确认。
* **第二次握手**：服务器收到SYN包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（Seq=y），即SYN+ACK包，此时服务器进入`SYN_RECV`状态。
* **第三次握手**：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入`ESTABLISHED`状态，完成三次握手。

> 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。

### 发送HTTP请求
通过TCP协议，将HTTP请求发送到服务器指定端口。

### 服务器处理请求并返回HTTP报文
HTTP报文分成三段：状态码，响应报头和响应报文。

### 浏览器解析渲染页面
* 解析HTML形成DOM树
* 解析CSS形成CSSOM树
* 合并DOM树和CSSOM树形成渲染树
* 浏览器开始渲染并绘制页面

### 连接结束
关闭TCP链接是一个双工的过程。
#### 四次挥手
* **第一次挥手**：客户端发送一个FIN，用来关闭客户端到服务器的数据传送，客户端进入`FIN_WAIT_1`状态。
* **第二次挥手**：服务器收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务器进入`CLOSE_WAIT`状态。
* **第三次挥手**：服务器发送一个FIN，用来关闭服务器到客户端的数据传送，服务器进入`LAST_ACK`状态。
* **第四次挥手**：客户端收到FIN后，客户端进入`TIME_WAIT`状态，接着发送一个ACK给服务器，确认序号为收到序号+1，服务器进入`CLOSED`状态。

## GET & POST
* **缓存**：GET请求会被浏览器主动缓存，而POST不会，除非手动设置。
* **敏感数据**：GET参数通过URL传递，POST则放在请求体（Request body）中，POST更适合传递敏感数据。
* **编码**：GET请求只能进行url编码，POST支持多种编码方式。
* **数据大小**：GET是通过浏览器URL发送请求，而URL是有长度限制的，POST理论上没有大小限制，实际取决于服务器的设置。

## HTTP缓存
简述，当浏览器再次访问一个已经访问过的资源时，它会这样做：
* 根据相关字段判断是否命中强缓存，如果命中，就直接使用缓存了。
  > 相关字段指的是**过期值**，HTTP/1.0是根据`Expires`这个字段，HTTP/1.1是根据`Cache-Control`字段的`max-age`值。为了兼容，通常两个字段都会返回。

  > 使用上一次记录的`max-age`+`Date`（HTTP/1.0使用`Expires`），得到一个过期时间，比较这个**过期时间**是否大于**当前时间**，如果是，则表示缓存还没有过期，仍然有效，否则表示缓存失效。

* 如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。
  > 该请求是携带着缓存去请求的，也就是携带`If-Modified-Since`和`If-None-Match`这两个字段去的。

* 如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存，否则，返回最新的资源。
  > 如果缓存有效，服务器会返回一个304重定向，并且带上新的缓存指令，浏览器继续**读取缓存数据**，并更新缓存时间。
  
  > 如果缓存无效，服务器会返回正常的200响应，并且带上新的缓存指令，浏览器读取**响应的数据**，并更新缓存时间。

## 常见性能优化手段

### 图片
* 精灵图（雪碧图）。
* 使用字体图标代替小图片。
* 图片懒加载。

### CSS
* 将CSS样式表放在页面顶部，避免已经呈现的节点会根据新的样式重绘。
* 避免使用层级较深的选择器，提供CSS渲染效率。
* 避免使用`calc`等CSS表达式，它会在页面缩放、滚动时都会重新进行计算。
* 能使用CSS实现的效果，尽量不使用JS来实现。

### JS
* 将JS脚本放到页面底部，避免堵塞DOM的渲染。或者在`script`标签上使用`defer`或`async`属性进行优化。
  > 解析器遇到JS脚本会停止渲染，优先去加载或者执行JS脚本，处理完毕后再继续渲染。<br>
  > `defer`属性：JS脚本的`加载`和DOM的渲染是并行的，JS脚本会等待DOM加载完才`执行`。<br>
  > `async`属性：JS脚本的`加载`和`执行`和DOM的渲染是并行的，JS脚本一旦加载完`立即执行`。
* 减少DOM的操作，如果必要，请批量操作DOM，避免频繁回流。
* 使用事件代理，避免为多个DOM元素绑定事件。 
* 使用节流、防抖，限制某个函数频繁触发。

### Vue
* 避免`v-if`和`v-for`在同一节点上使用，`v-for`的优先级比`v-if`高，造成每次循环都会`v-if`判断。
  > Vue3中已将 v-if 的优先级调高于 v-for。
* 给`v-for`的元素加上`key`标识，优化diff的效率。
* 不需要响应式的数据使用`Object.freeze`冻结起来。
* 合理使用`v-show`/`v-if`。
  > `v-show`只是通过`display`控制元素的显隐。`v-if`会操作元素/组件的创建和销毁，代表生命周期会重新走一遍。
* 路由懒加载。
* 函数式组件。
* 善用`keep-alive`缓存组件。
* 定时器和全局事件记得销毁。

### HTTP
* 资源压缩：HTML、CSS、JS、图片都可以压缩。
* 并行连接：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量。
* 使用CDN。
* 使用HTTP缓存：添加`Expires`或者`Cache-Control`响应头。
* Gzip压缩。

  